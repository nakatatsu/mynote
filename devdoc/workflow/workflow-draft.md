# 開発ワークフロー

このドキュメントでは、要件定義からコード実装まで、プロジェクトで推奨される開発フローを示します。

## 全体フロー概要

```
要件定義 → ドメインモデリング → アーキテクチャ可視化 → 実装
```

**ドキュメント格納先**:
- Phase 1~2 および Phase 3（システムコンテキスト図、コンテナ図、デプロイメント図、ダイナミック図、システムランドスケープ図）: `requirements/` に格納
- **コンポーネント図・コード図**: Phase 4で各機能の設計時に作成し、各コードディレクトリ（`backend/`, `frontend/` など）に格納


---

## スラッシュコマンド実行の原則

**重要**: このワークフローで使用する全てのスラッシュコマンド（`/requirement*`, `/domain*`, `/c4model*`, `/speckit.*`, `/frontend.*`, `/infrastructure.*` など）を実行する前に、必ず `.claude/commands/` にあるコマンドファイルを読んで動作を理解すること。

- コマンドファイルには、実行ステップ、前提条件、重要な注意事項が詳細に記載されている
- workflow.mdには各コマンドの概要のみ記載し、詳細はコマンドファイルに委譲する
- コマンドファイルを読まずに実行すると、重要なステップを見落とす可能性がある

## ワークフロー管理と設計書作成管理の分離

ワークフローはSpeckit互換のplan -> taskフローで実現する。
作るべき設計書は設計書作成フローで管理する。
つまりは「設計書の作成は、Speckit互換のplan -> taskフローで実現される」。

憲章にもあるとおり「どういう経緯であれ期待通りのアウトプットが出来ているならそれでよい」

---

## Phase 1: 要件定義 (Requirement Phase)

システム開発の目的と要件を明確化します。

### 1.1 背景・目的の整理

**コマンド**: `/requirement001-purpose [working-directory]`

**目的**: システム開発の「なぜ」を明確化

**出力**: `背景・目的.md`

**記載内容**:
- 背景: なぜシステム開発が必要か
- 実現したいこと: システムで実現すること
- 期待される効果: 定量的・定性的な効果

### 1.2 ユーザーシナリオ作成

**コマンド**: `/requirement002-user-scenario [working-directory]`

**目的**: 具体的な利用場面を描く

**出力**: `ユーザーシナリオ.md`

**記載形式**: Given-When-Then形式
- Given（前提）: 誰が、どんな状況で
- When（操作）: システムで何をして
- Then（結果）: どうなったか

### 1.3 ユースケース整理

**コマンド**: `/requirement003-usecase [working-directory]`

**目的**: 誰がシステムで何をするかを整理

**出力**: `ユースケース.md`

**記載内容**:
- ユーザー種別ごとの役割
- 各ユーザーがシステムで行うこと

### 1.4 前提と制約条件 (オプション)

**コマンド**: `/requirement004-constraints [working-directory]`

**目的**: 開発上の重要な制約・前提を明確化

**出力**: `前提と制約条件.md`

**記載内容**:
- 前提: ユーザー数、データ規模、利用環境等
- 制約: 予算、期限、技術的制約等

**注意**: 重要な制約や前提がある場合のみ記載

---

## Phase 2: ドメインモデリング (Domain Modeling Phase)

ビジネスドメインの知識を整理し、ドメインモデルを構築します。

### 2.1 用語集（ユビキタス言語）作成

**コマンド**: `/domain001-glossary [working-directory-path]`

**目的**: ドメイン用語を統一し、チーム共通言語を確立

**出力**: `用語集.md`

**実施内容**:
- シナリオから名詞を抽出
- ドメイン用語として整理
- 用語の揺らぎを統一

### 2.2 ビジネスルール・制約の整理

**コマンド**: `/domain002-business-rules [working-directory-path]`

**目的**: 「常に守られるべき条件」を明文化

**出力**: `ビジネスルール.md`

**実施内容**:
- シナリオに埋もれているルールを抽出
- 不変条件として整理
- 暗黙のルールも明文化

### 2.3 ドメインオブジェクト設計

**コマンド**: `/domain003-aggregates [working-directory-path]`

**目的**: エンティティ、値オブジェクト、集約を設計

**出力**: `ドメインオブジェクト.md`

**実施内容**:
- 用語集の概念をエンティティ/値オブジェクトに分類
- 集約の境界を決定
- トランザクション境界の明確化

### 2.4 ドメインサービス・イベント定義

**コマンド**: `/domain004-services-events [working-directory-path]`

**目的**: ドメインサービスとドメインイベントを定義

**出力**: `ドメインサービス・イベント.md`

### 2.5 コンテキストマップ作成

**コマンド**: `/domain005-context-map [working-directory-path]`

**目的**: 境界づけられたコンテキストの関係を可視化

**出力**: `コンテキストマップ.md`

---

## Phase 3: アーキテクチャ可視化 (C4 Model Phase)

C4モデルを使用してアーキテクチャを段階的に可視化します。

### 3.1 システムコンテキスト図

**コマンド**: `/c4model001-context [working-directory]`

**目的**: システムの全体像、ユーザー、外部システムを可視化

**出力**: `システムコンテキスト図.md` (Mermaid C4Context)

**記載内容**:
- 対象システム
- ユーザー（アクター）
- 外部システム
- 関係性

### 3.2 コンテナ図

**コマンド**: `/c4model002-container [working-directory]`

**目的**: アプリケーション、データストア等の構成要素を可視化

**出力**: `コンテナ図.md`

### 3.3 デプロイメント図

**コマンド**: `/c4model005-deployment [working-directory]`

**目的**: インフラ環境を可視化

**出力**: `デプロイメント図.md`

### 3.4 ダイナミック図 (オプション)

**コマンド**: `/c4model006-dynamic [working-directory]`

**目的**: 動的な振る舞いを可視化

**出力**: `ダイナミック図.md`

**作成判断基準**:
- **3ステップ以上の複雑な処理フロー**がある場合に作成
- 単純な CRUD 操作や直線的な処理には不要
- 複数コンポーネント間の協調動作、分岐・ループを含む処理に有効

### 3.5 システムランドスケープ図 (オプション)

**コマンド**: `/c4model007-landscape [working-directory]`

**目的**: 複数システムの関係を可視化

**出力**: `システムランドスケープ図.md`

**作成判断基準**:
- **2つ以上のシステム**が存在する場合に作成
- 単一システムのプロジェクトには不要（システムコンテキスト図で十分）
- 複数システムの依存関係やデータフローを俯瞰する必要がある場合に有効

---

## Phase 4: 実装設計と実装 (Implementation Phase)

**Phase 4の基本原則**：
1. **成果物で定義する**：ワークフローではなく、何を作るかで定義する
2. **反復性を前提とする**：一度で完結しない、試行錯誤と手戻りを織り込む
3. **レイヤー特性を尊重する**：各レイヤーは独自の最適なプロセスを持つ
4. **依存順序を意識する**：Contracts → Infrastructure → Backend → Frontend

**重要な考え方**：
- Backend、Frontend、Spec、Infrastructureを順番通りに完了させることは非現実的
- 実装は反復的で非線形なプロセスである
- 各レイヤー間を行き来しながら、試行錯誤を重ねて進める
- 手戻りは問題ではなく、発見的設計の自然な結果である

---

### 4.1 契約定義（Contracts/API Specification）

**成果物**
- Typespec用の定義を作成し、フロントエンド用のAPI用コードのビルドまで実行せよ
    - OpenAPI仕様書
    - 型定義（TypeScript型、Go構造体）
    - リクエスト/レスポンススキーマ
    - エラーコード・メッセージ仕様
    - 認証・認可仕様

### 4.2 インフラストラクチャ（Infrastructure as Code）

**成果物**：
- Terraformモジュール（main.tf, variables.tf, outputs.tf）
- 環境別設定（dev.tfvars, stg.tfvars, prd.tfvars）
- ネットワーク設計（VPC, Subnet, Route）
- セキュリティ設計（IAM, Security Group, KMS）
- 可観測性設定（CloudWatch, Logging, Monitoring）
- インフラテスト（terraform test）

**レイヤー特性**：
- 宣言的、冪等性
- 環境差分管理が重要
- 他レイヤーの実行基盤

**開発アプローチ**：
- モジュール単位で設計・実装・検証
- terraform plan → apply → 検証の反復
- 環境ごとの差分を明示的に管理
- ステート管理の厳格な運用

**反復サイクル**：
設計 → モジュール実装 → plan確認 → apply → 動作検証 → 改善

---

### 4.3 バックエンド（Backend API - Go）

**成果物**：
- **構造設計**：コンポーネント図、コード図（機能仕様確定後に作成）
- **ドメイン層**：エンティティ、値オブジェクト、集約、ドメインサービス
- **ユースケース層**：アプリケーションサービス、ビジネスロジック
- **インフラ層**：リポジトリ実装、外部サービスアダプタ
- **プレゼンテーション層**：HTTPハンドラー、ミドルウェア
- **テスト**：ユニットテスト、統合テスト、契約テスト

**特性**：
- クリーンアーキテクチャ

**開発アプローチ**：
- 機能単位（集約/モジュール単位）で設計・実装
- 内側から外側へ：Entity → UseCase → Repository → Handler
- テスト駆動開発（TDD）
- 依存性注入（DI）パターン


### 4.4 フロントエンド（Frontend - Next.js/React）

- 画面遷移図
    - `documents/以下とrequirements/以下のドキュメントで関係するところを読んだうえで、frontend/画面遷移図.mdを作成してくれ。特にrequirements/ユースケース.mdを確認のこと`
- 各画面仕様書
    - documents/以下とrequirements/以下のドキュメントで関係するところを読んだうえで、特にrequirements/ユースケース.mdを確認のこと、frontend/画面遷移図.mdに完全に準拠し、一切の疎漏や重複なくフロントエンド画面仕様書を作成し、それぞれの画面についての下記を記載してくれ
        - 表示項目（共通レイアウト除く）
        - フォーム（あれば）
        - 必要なAPI（機能に絶対必須のもの。あれば便利程度のものはノイズとなるため足さない）
- スキャフォールド
    - documents/frontend/technical-context.md に記載の通りNextJS16でプロジェクトを作り、documents/frontend/coding-standard.md に既定の通りのディレクトリ構成で空ディレクトリでも構わないので作成してくれ。既存ファイルを一時的に退避してcreate-next-appを実行し、完了後に戻すこと。
- 各画面
    - spec/以下のビルドをまず実施。その後画面仕様書.mdに従って、全画面を作ってほしいと思う　まずチェックリストをこのtasks.mdに追記してくれ。Typespecによってビルドされるファイルは決して削除・更新しないこと


**成果物**：
- **機能コンポーネント**：features配下のドメイン機能
- **状態管理**：グローバル状態、フォーム状態
- **テスト**：コンポーネントテスト、E2Eテスト

**開発アプローチ**：
- 画面単位/機能単位で設計・実装

